#!/usr/bin/env node
const { parseArgs } = require('node:util');
const { createHash } = require('crypto');

function hashCommitment(seed, nonce) {
  return createHash('sha256').update(seed).update(nonce).digest('hex');
}

function* prng(seed) {
  let counter = 0;
  while (true) {
    const hash = createHash('sha256')
      .update(seed)
      .update(Buffer.from(counter.toString()))
      .digest();
    const rand = hash.readUInt32BE(0) / 0xffffffff;
    counter += 1;
    yield rand;
  }
}

function shuffle(items, seed) {
  const arr = items.slice();
  const rnd = prng(seed);
  for (let i = arr.length - 1; i > 0; i--) {
    const r = rnd.next().value;
    const j = Math.floor(r * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function standardDeck() {
  return Array.from({ length: 52 }, (_, i) => i);
}

function verifyProof(proof) {
  const seed = Buffer.from(proof.seed, 'hex');
  const nonce = Buffer.from(proof.nonce, 'hex');
  return hashCommitment(seed, nonce) === proof.commitment;
}

async function verifyHandProof(handId, baseUrl) {
  const proofRes = await fetch(`${baseUrl}/hands/${handId}/proof`);
  if (!proofRes.ok) throw new Error('Failed to fetch proof');
  const proof = await proofRes.json();
  if (!verifyProof(proof)) throw new Error('Invalid proof: commitment mismatch');

  const logRes = await fetch(`${baseUrl}/hands/${handId}/log`);
  if (!logRes.ok) throw new Error('Failed to fetch log');
  const logText = await logRes.text();

  let deck;
  for (const line of logText.trim().split('\n')) {
    if (!line) continue;
    if (line.startsWith('[')) {
      try {
        const entry = JSON.parse(line);
        const d = entry[2]?.deck;
        if (Array.isArray(d)) {
          deck = d;
          break;
        }
      } catch {}
    }
  }
  if (!Array.isArray(deck)) throw new Error('Deck not found in log');

  const expected = shuffle(standardDeck(), Buffer.from(proof.seed, 'hex'));
  const match = deck.length === expected.length && deck.every((v,i)=>v===expected[i]);
  if (!match) throw new Error('Deck mismatch');
}

async function main() {
  const { values, positionals } = parseArgs({
    args: process.argv.slice(2),
    options: { base: { type: 'string', short: 'b' } },
    allowPositionals: true,
  });
  const handId = positionals[0];
  const baseUrl = values.base || 'http://localhost:3000';
  if (!handId) {
    console.error('Usage: verify-proof <handId> [--base <url>]');
    process.exit(1);
  }
  try {
    await verifyHandProof(handId, baseUrl);
    console.log(`Proof verified for hand ${handId}`);
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = { verifyHandProof };
